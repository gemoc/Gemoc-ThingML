object EString
	@java_type "String"

datatype EInteger<4>
	@java_type "Integer"

thing fragment SynchroMsgs {
	message start()
	message stop()
}

thing fragment PortMsgs {
	message deliver(target : EInteger, content : EString)
	message fetch(target : EInteger)
	message ping(number : EInteger)
	message request(target : EInteger, content : EString)
	message none()
}

thing Ports includes SynchroMsgs, PortMsgs {

	readonly property port_number : EInteger = 0
	readonly property buffer_size : EInteger = 100
	property buffer_head : EInteger = 0
	property buffer_queue : EInteger = 0
	property target_buffer : EInteger[buffer_size]
	property message_buffer : EString[buffer_size]

	required port synchro {
		receives start
		receives stop
	}

	provided port server {
		receives deliver
		receives fetch
		sends ping
		sends request
		sends none
	}

	function write_buffer(target : EInteger, mess : EString) do
		var next_head : EInteger = (buffer_head + 1) % buffer_size
		if (next_head == buffer_queue) do
			print "ALERT: buffer " + port_number + " is full!\n"
			print "       message: \"" + mess + "\" for target " + target + " is dropped!\n"
		end else do
			target_buffer[buffer_head] = target
			message_buffer[buffer_head] = mess
			buffer_head = next_head
		end
	end

	function read_buffer() : EInteger do
		if (buffer_queue == buffer_head) do
			return -1
		end else do
			var return_value : EInteger = buffer_queue
			buffer_queue = (buffer_queue + 1) % buffer_size
			return return_value
		end
	end

	statechart Behaviour init Inactive {

		state Inactive {
			transition start -> Active
				event synchro?start
		}

		state Active {
			on entry do
				if (port_number == 2) do
					write_buffer(1, "hello")
					print "pinging !!!!\n"
					server!ping(port_number)
				end
			end

			internal on_fetch
				event fetch : server?fetch
				guard fetch.target == port_number
				action do
					var index : EInteger = read_buffer()
					if (index < 0) do
						server!none()
					end else do
						server!request(target_buffer[index], message_buffer[index])
					end
				end

			internal on_deliver
				event deliver : server?deliver
				guard deliver.target == port_number
				action print "deliver received\n"

			transition stop -> End
				event synchro?stop
		}

		final state End {
			on entry print "Port " + port_number + " stopped\n"
		}
	}
}

thing Server includes SynchroMsgs, PortMsgs {

	property side : EInteger = 0
	property turn : EInteger = 0
	property target : EInteger = 0
	property message_text : EString = ""
	property waiting : EInteger = 0

	provided port synchro {
		sends start
		sends stop
	}

	required port ports {
		sends deliver
		sends fetch
		receives ping
		receives request
		receives none
	}

	statechart Behaviour init Active {

		on entry do
			print "Server started\n"
			synchro!start()
		end

		composite state Active init Deliver {

			internal on_ping
				event ports?ping
				action waiting++

			state Deliver {
				on entry do
					print "side " + side
					side = (side % 2) + 1
					print " --> " + side + "\n"
					if (side == 1) turn++

					if (target == side) do
						print "deliver on port " + side + "\n"
						ports!deliver(side, message_text)
						target = 0
						waiting--
					end else do
						print "nothing to deliver for " + side + "\n"
					end
				end

				transition delivered -> Fetch
					guard waiting > 0
					action print "waiting: " + waiting + "\n"
			}

			state Fetch {
				on entry do
					print "fetch on port " + side + "\n"
					ports!fetch(side)
				end

				transition nothing_fetched -> Deliver
					event ports?none
					action print "nothing fetched\n"

				transition fetched -> Deliver
					event request : ports?request
					action do
						target = request.target
						message_text = request.content
						print "fetched request '" + message_text + "' for " + target + "\n"
					end
			}

			transition stop -> End
				guard turn > 3
		}

		final state End {
			on entry do
				synchro!stop()
				print "Server stopped\n"
			end
		}
	}
}

configuration RingConfig {
	instance server : Server

	instance port1 : Ports
	set port1.port_number = 1
	connector port1.synchro => server.synchro
	connector server.ports => port1.server

	instance port2 : Ports
	set port2.port_number = 2
	connector port2.synchro => server.synchro
	connector server.ports => port2.server
}
