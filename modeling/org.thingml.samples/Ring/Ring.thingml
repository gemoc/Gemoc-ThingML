object EString
	@java_type "String"

datatype EInteger<4>
	@java_type "Integer"

datatype EBoolean<1>
	@java_type "Boolean"

thing fragment SynchroMsgs {
	message start()
	message stop()
	message stop_request(emmiter : EInteger)
}

thing fragment DataMsgs {
	// server wants to give a message to client
	message deliver(target : EInteger, content : EString)

	// client gave a message to server
	message ping()
	message fetch(target : EInteger)
	message none()
	message request(target : EInteger, content : EString)
	message broadcast(content : EString)
}

thing Client includes SynchroMsgs, DataMsgs {

	readonly property client_number : EInteger = 0

	required port server {
		receives deliver
		receives fetch
		sends ping
		sends request
		sends broadcast
		sends none
	}

	required port synchro {
		receives start
		receives stop
		sends stop_request
	}

	function log(line : EString) do
		print "Client " + client_number + " : " + line + "\n"
	end

	statechart Behaviour init Inactive {

		state Inactive {
			transition start -> Active
				event synchro?start
		}

		composite state Active init SayHello {
			on entry do
				log("started")
			end

			state SayHello {
				on entry do
					log("ping server")
					server!ping()
				end

				transition on_fetch -> Wait
					event fetch : server?fetch
					guard fetch.target == client_number
					action do
						server!broadcast("hello, I am client " + client_number)
						synchro!stop_request(client_number)
					end
			}

			final state Wait {}

			internal on_fetch
				event fetch : server?fetch
				guard fetch.target == client_number
				action do
					server!none()
				end

			internal on_deliver
				event deliver : server?deliver
				guard deliver.target == client_number
				action do
					log("message received : \"" + deliver.content + "\"")
				end

			transition stop -> End
				event synchro?stop
		}

		final state End {
			on entry log("stopped")
		}
	}
}

thing Server includes SynchroMsgs, DataMsgs {

	readonly property number_sides : EInteger = 0
	property stop_requests : EInteger[number_sides]
	property side : EInteger = 1
	property target : EInteger = 0
	property message_text : EString = ""
	property waiting : EInteger = 0

	provided port synchro {
		sends start
		sends stop
		receives stop_request
	}

	provided port clients {
		sends deliver
		sends fetch
		receives ping
		receives request
		receives broadcast
		receives none
	}

	function log(line : EString) do
		print "Server   : " + line + "\n"
	end

	function init_stop_requests() do
		var i : EInteger = 0
		while (i < number_sides) do
			stop_requests[i] = 0
			i++
		end
	end

	function can_stop() : EBoolean do
		var number : EInteger = number_sides
		var i : EInteger = 0
		while (i < number_sides) do
			if (stop_requests[i] > 0) number--
			i++
		end
		return number == 0
	end

	function switch_side() do
		var new_side : EInteger = (side % number_sides) + 1
		log("side " + side + " --> " + new_side)
		side = new_side
	end

	function deliver() do
		if (target == side) do
			log("deliver to client " + side)
			clients!deliver(side, message_text)
			target = 0
			waiting--
		end else do
			log("nothing to deliver for client " + side)
		end
	end

	function fetch() do
		log("fetch on client " + side)
		clients!fetch(side)
	end

	statechart Behaviour init Active {

		on entry do
			init_stop_requests()
			log("started")
			synchro!start()
		end

		composite state Active init Wait {

			internal on_ping
				event clients?ping
				action waiting++

			state Wait {
				internal not_delivered
					guard waiting > 0 and target > 0
					action do
						switch_side()
						deliver()
					end

				transition delivered -> Fetch
					guard waiting > 0 and target == 0
					action log(waiting + " waiting")

			}

			state Fetch {
				on entry do
					fetch()
				end

				internal not_fetched
					event clients?none
					action do
						log("nothing fetched")
						switch_side()
						fetch()
					end

				transition request_fetched -> Wait
					event request : clients?request
					action do
						target = request.target
						message_text = request.content
						log("fetched request '" + message_text + "' for " + target)
						switch_side()
						deliver()
					end

				transition broadcast_fetched -> Wait
					event broadcast : clients?broadcast
					action do
						message_text = broadcast.content
						log("fetched broadcast '" + message_text + "'")
						var sender : EInteger = side
						switch_side()
						while (side != sender) do
							target = side
							deliver()
							switch_side()
						end
						switch_side()
					end
			}

			internal on_stop
				event stop_request : synchro?stop_request
				action do
					log("stop request from client " + stop_request.emmiter)
					stop_requests[stop_request.emmiter - 1] = 1
				end

			transition stop -> End
				guard can_stop()
		}

		final state End {
			on entry do
				synchro!stop()
				log("stopped")
			end
		}
	}
}

configuration RingConfig {
	instance server : Server
	set server.number_sides = 2

	instance client1 : Client
	set client1.client_number = 1
	connector client1.synchro => server.synchro
	connector client1.server => server.clients

	instance client2 : Client
	set client2.client_number = 2
	connector client2.synchro => server.synchro
	connector client2.server => server.clients
}
