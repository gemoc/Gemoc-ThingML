object EString
	@java_type "String"

datatype EInteger<4>
	@java_type "Integer"

thing fragment SynchroMsgs {
	message start()
	message stop()
}

thing fragment ServerMsgs {
	// server wants to give a message to client
	message deliver(target : EInteger, content : EString)

	// client gave a message to server
	message ping(number : EInteger)
	message fetch(target : EInteger)
	message none()
	message request(target : EInteger, content : EString)
	message broadcast(sender : EInteger, content : EString)
}

thing fragment ClientMsgs {
	// client wants to give a message to server
	message client_request(target : EInteger, content : EString)
	message client_broadcast(content : EString)

	// server gave a message to client
	message client_deliver(content : EString)
}

thing Client includes SynchroMsgs, ClientMsgs {

	readonly property client_number : EInteger = 0

	required port server_port {
		sends client_request
		sends client_broadcast
		receives client_deliver
	}

	required port synchro {
		receives start
		receives stop
	}

	function log(line : EString) do
		print "Client " + client_number + " : " + line + "\n"
	end

	statechart Behaviour init Inactive {

		state Inactive {
			transition start -> Active
				event synchro?start
		}

		state Active {
			on entry do
				log("started")
				server_port!client_broadcast("hello, I am client " + client_number)
			end

			internal on_deliver
				event client_deliver : server_port?client_deliver
				action do
					log("message received : \"" + client_deliver.content + "\"")
				end

			transition stop -> End
				event synchro?stop
		}

		final state End {
			on entry log("stopped")
		}
	}
}

thing Ports includes SynchroMsgs, ClientMsgs, ServerMsgs {

	readonly property port_number : EInteger = 0
	readonly property buffer_size : EInteger = 100
	property buffer_head : EInteger = 0
	property buffer_queue : EInteger = 0
	property target_buffer : EInteger[buffer_size]
	property message_buffer : EString[buffer_size]

	required port server_synchro {
		receives start
		receives stop
	}

	provided port client_synchro {
		sends start
		sends stop
	}

	provided port client {
		receives client_request
		receives client_broadcast
		sends client_deliver
	}

	provided port server {
		receives deliver
		receives fetch
		sends ping
		sends request
		sends broadcast
		sends none
	}

	function log(line : EString) do
		print "Port " + port_number + "   : " + line + "\n"
	end

	function write_buffer(target : EInteger, mess : EString) do
		var next_head : EInteger = (buffer_head + 1) % buffer_size
		if (next_head == buffer_queue) do
			print "ALERT: buffer " + port_number + " is full!\n"
			print "       message: \"" + mess + "\" for target " + target + " is dropped!\n"
		end else do
			target_buffer[buffer_head] = target
			message_buffer[buffer_head] = mess
			buffer_head = next_head
		end
	end

	function read_buffer() : EInteger do
		if (buffer_queue == buffer_head) do
			return -1
		end else do
			var return_value : EInteger = buffer_queue
			buffer_queue = (buffer_queue + 1) % buffer_size
			return return_value
		end
	end

	statechart Behaviour init Inactive {

		state Inactive {
			transition start -> Active
				event server_synchro?start
				action client_synchro!start()
		}

		state Active {
			on entry log("started")

			internal on_request
				event client_request : client?client_request
				action do
					write_buffer(client_request.target, client_request.content)
					server!ping(port_number)
				end

			internal on_broadcast
				event client_broadcast : client?client_broadcast
				action do
					write_buffer(0, client_broadcast.content)
					server!ping(port_number)
				end

			internal on_fetch
				event fetch : server?fetch
				guard fetch.target == port_number
				action do
					var index : EInteger = read_buffer()
					if (index < 0) do
						server!none()
					end else if (target_buffer[index] > 0) do
						server!request(target_buffer[index], message_buffer[index])
					end else do
						server!broadcast(port_number, message_buffer[index])
					end
				end

			internal on_deliver
				event deliver : server?deliver
				guard deliver.target == port_number
				action client!client_deliver(deliver.content)

			transition stop -> End
				event server_synchro?stop
				action client_synchro!stop()
		}

		final state End {
			on entry log("stopped")
		}
	}
}

thing Server includes SynchroMsgs, ServerMsgs {

	readonly property number_sides : EInteger = 0
	property side : EInteger = 1
	property turn : EInteger = 0
	property target : EInteger = 0
	property message_text : EString = ""
	property waiting : EInteger = 0

	provided port synchro {
		sends start
		sends stop
	}

	required port ports {
		sends deliver
		sends fetch
		receives ping
		receives request
		receives broadcast
		receives none
	}

	function log(line : EString) do
		print "Server   : " + line + "\n"
	end

	function switch_side() do
		var new_side : EInteger = (side % number_sides) + 1
		log("side " + side + " --> " + new_side)
		side = new_side
		if (side == 1) turn++
	end

	function deliver() do
		if (target == side) do
			log("deliver on port " + side)
			ports!deliver(side, message_text)
			target = 0
			waiting--
		end else do
			log("nothing to deliver for " + side)
		end
	end

	function fetch() do
		log("fetch on port " + side)
		ports!fetch(side)
	end

	statechart Behaviour init Active {

		on entry do
			log("started")
			synchro!start()
		end

		composite state Active init Wait {

			internal on_ping
				event ports?ping
				action waiting++

			state Wait {
				internal not_delivered
					guard waiting > 0 and target > 0
					action do
						switch_side()
						deliver()
					end

				transition delivered -> Fetch
					guard waiting > 0 and target == 0
					action log(waiting + " waiting")

			}

			state Fetch {
				on entry do
					fetch()
				end

				internal not_fetched
					event ports?none
					action do
						log("nothing fetched")
						switch_side()
						fetch()
					end

				transition request_fetched -> Wait
					event request : ports?request
					action do
						target = request.target
						message_text = request.content
						log("fetched request '" + message_text + "' for " + target)
						switch_side()
						deliver()
					end

				transition broadcast_fetched -> Wait
					event broadcast : ports?broadcast
					action do
						message_text = broadcast.content
						log("fetched broadcast '" + message_text + "'")
						switch_side()
						while (side != broadcast.sender) do
							target = side
							deliver()
							switch_side()
						end
						switch_side()
					end
			}

			transition stop -> End
				guard turn > 3
		}

		final state End {
			on entry do
				synchro!stop()
				log("stopped")
			end
		}
	}
}

configuration RingConfig {
	instance server : Server
	set server.number_sides = 2

	instance port1 : Ports
	set port1.port_number = 1
	connector port1.server_synchro => server.synchro
	connector server.ports => port1.server

	instance client1 : Client
	set client1.client_number = 1
	connector client1.synchro => port1.client_synchro
	connector client1.server_port => port1.client

	instance port2 : Ports
	set port2.port_number = 2
	connector port2.server_synchro => server.synchro
	connector server.ports => port2.server

	instance client2 : Client
	set client2.client_number = 2
	connector client2.synchro => port2.client_synchro
	connector client2.server_port => port2.client
}
